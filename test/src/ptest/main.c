/*
 * Copyright (C) 2014-2019 fdns Authors
 *
 * This file is part of fdns project
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/
#include "stub.h"
#define INTERTEST_DELAY 2000 // 2 ms

int pktcnt = 0;
void sendpkt(uint8_t *pkt, ssize_t len) {
	DnsDestination dest;
	uint8_t *rv = dns_parser(pkt, &len, &dest);
	pktcnt++;
	printf("cnt %d, %s\n", pktcnt, (rv)? "(not nil)":"(nil)");
	usleep(INTERTEST_DELAY);
}

//***************************************************
// pkt len test
//***************************************************

static void test_debug(void) {
	pktcnt = 0;
/* Frame (95 bytes) */
static unsigned char pkt[95] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* ........ */
0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x45, 0x00, /* ......E. */
0x00, 0x51, 0x1b, 0x0a, 0x40, 0x00, 0x40, 0x11, /* .Q..@.@. */
0x20, 0x8f, 0x7f, 0x00, 0x00, 0x01, 0x7f, 0x01, /*  ....... */
0x01, 0x01, 0xa1, 0x62, 0x00, 0x35, 0x00, 0x3d, /* ...b.5.= */
0xff, 0x51, 0x5d, 0x5d, 0x01, 0x00, 0x00, 0x01, /* .Q]].... */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x74, /* .......t */
0x72, 0x61, 0x63, 0x6b, 0x69, 0x6e, 0x67, 0x2d, /* racking- */
0x70, 0x72, 0x6f, 0x74, 0x65, 0x63, 0x74, 0x69, /* protecti */
0x6f, 0x6e, 0x03, 0x63, 0x64, 0x6e, 0x07, 0x6d, /* on.cdn.m */
0x6f, 0x7a, 0x69, 0x6c, 0x6c, 0x61, 0x03, 0x6e, /* ozilla.n */
0x65, 0x74, 0x00, 0x00, 0x01, 0x00, 0x01        /* et..... */
};
	sendpkt(pkt + 42, 95 - 42);
}



static void test_pktlen(void) {
	printf("TESTING: packet length test\n");
	pktcnt = 0;

	 // valid request type A, www.netbsd.org if the length of data sent out is 74
	unsigned char pkt[34] = {
		0x75, 0xc0,   // id
		0x01, 0x00,  // flags
		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // q/a
		0x03, 0x77, 0x77, 0x77, // www
		0x06, 0x6e, 0x65, 0x74, 0x62, 0x73, 0x64, // .netbsd
		0x03, 0x6f, 0x72, 0x67, 0x00, // .org \0
		0x00, 0x01, 0x00, 0x01, // type A, class IN
		0x00, 0x00  // overrun
	};

	unsigned i;
	for (i = 1; i < sizeof(pkt); i++) {
		sendpkt(pkt, i);
	}
}

static void test_wrongclass(void) {
	printf("TESTING: packet class test\n");
	pktcnt = 0;

	 // valid request type A, www.netbsd.org if the length of data sent out is 74
	unsigned char pkt[32] = {
		0x75, 0xc0,   // id
		0x01, 0x00,  // flags
		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //q/a
		0x03, 0x77, 0x77, 0x77, // www
		0x06, 0x6e, 0x65, 0x74, 0x62, 0x73, 0x64, // .netbsd
		0x03, 0x6f, 0x72, 0x67, 0x00, // .org \0
		0x00, 0x01, 0x00, 0x21, // type A, class IN
	};

	sendpkt(pkt, sizeof(pkt));
}

static void test_rrtype(void) {
	printf("TESTING: packet rr type test\n");
	pktcnt = 0;

	 // valid request type A, www.netbsd.org if the length of data sent out is 74
	unsigned char pkt[32] = {
		0x75, 0xc0,   // id
/* 2 */		0x01, 0x00,  // flags
/* 4 */		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // q/a
/* 12 */		0x03, 0x77, 0x77, 0x77, // www
/* 16 */		0x06, 0x6e, 0x65, 0x74, 0x62, 0x73, 0x64, // .netbsd
/* 23 */		0x03, 0x6f, 0x72, 0x67, 0x00, // .org \0
/* 28 */		0x00, 0x01, 0x00, 0x01, // type A, class IN
	};

	int i;
	for (i = 0; i <= 255; i++) {
		pkt[29] = (uint8_t) i;
		sendpkt(pkt, sizeof(pkt));
	}
}

// wrong question/answer/authorative/additional section
static void test_wrongqsection(void) {
	printf("TESTING: wrong question/answer section\n");
	pktcnt = 0;

	 // valid request type A, www.netbsd.org if the length of data sent out is 74
	unsigned char pkt[32] = {
		0x75, 0xc0,   // id
/* 2 */		0x01, 0x00,  // flags
/* 4 */		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // q/a
/* 12 */		0x03, 0x77, 0x77, 0x77, // www
/* 16 */		0x06, 0x6e, 0x65, 0x74, 0x62, 0x73, 0x64, // .netbsd
/* 23 */		0x03, 0x6f, 0x72, 0x67, 0x00, // .org \0
/* 28 */		0x00, 0x01, 0x00, 0x01, // type A, class IN
	};

	pkt[5] = 3;
	sendpkt(pkt, sizeof(pkt));
	pkt[5] = 1;

	pkt[6] = 24;
	sendpkt(pkt, sizeof(pkt));
	pkt[7] = 0;

	pkt[7] = 1;
	sendpkt(pkt, sizeof(pkt));
	pkt[7] = 0;

	pkt[8] = 100;
	sendpkt(pkt, sizeof(pkt));
	pkt[8] = 0;

	pkt[9] = 1;
	sendpkt(pkt, sizeof(pkt));
	pkt[9] = 0;

	pkt[10] = 1;
	sendpkt(pkt, sizeof(pkt));
	pkt[10] = 0;

	pkt[11] = 1;
	sendpkt(pkt, sizeof(pkt));
	pkt[11] = 0;

}

// wrong question/answer/authorative/additional section
static void test_compressedq(void) {
	printf("TESTING:compressed question\n");
	pktcnt = 0;

	 // valid request type A, www.netbsd.org if the length of data sent out is 74
	unsigned char pkt[32] = {
		0x75, 0xc0,   // id
/* 2 */		0x01, 0x00,  // flags
/* 4 */		0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // q/a
/* 12 */		0x03, 0x77, 0x77, 0x77, // www
/* 16 */		0x06, 0x6e, 0x65, 0x74, 0x62, 0x73, 0x64, // .netbsd
/* 23 */		0x03, 0x6f, 0x72, 0x67, 0x00, // .org \0
/* 28 */		0x00, 0x01, 0x00, 0x01, // type A, class IN
	};

	uint8_t compress[3] = {0xc0, 0x0c, 0x00};
	uint8_t tmp[3];

	int i;
	for (i = 12; i < 23; i++) {
		memcpy(tmp, pkt + i, 3);
		memcpy(pkt + i, compress, 3);
		sendpkt(pkt, sizeof(pkt));
		memcpy(pkt + i, tmp, 3);
	}
}

// checking some classic exploits
static void test_classicexploits(void) {
	printf("TESTING: some classic exploits\n");
	pktcnt = 0;

/* Frame (77 bytes)  - exploit, endless, pointing to itself message decompression flaw */
static unsigned char pkt1[77] = {
0x00, 0x60, 0x94, 0xeb, 0x55, 0x2f, 0x00, 0xc0, /* .`..U/.. */
0x4f, 0x6b, 0x9f, 0xe0, 0x08, 0x00, 0x45, 0x00, /* Ok....E. */
0x00, 0x3f, 0x3b, 0x89, 0x00, 0x00, 0x40, 0x11, /* .?;...@. */
0x86, 0x78, 0x0a, 0x00, 0x00, 0x01, 0x92, 0x54, /* .x.....T */
0x1c, 0x58, 0x04, 0x00, 0x00, 0x35, 0x00, 0x08, /* .X...5.. */
0x82, 0xb7, 0xed, 0x69, 0x00, 0x00, 0x00, 0x01, /* ...i.... */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0c, /* ........ */
0xc0, 0x07, 0xc0, 0x10, 0xc0, 0x17, 0xc0, 0x20, /* .......  */
0xc0, 0x27, 0xc0, 0x30, 0xc0, 0xff, 0xcf, 0x00, /* .'.0.... */
0x00, 0x00, 0x01, 0x00, 0x01                    /* ..... */
};
	sendpkt(pkt1 + 42, 77 - 42);

/* Frame (77 bytes) - exploit, endless cross referencing at message decompression. */
static unsigned char pkt2[77] = {
0x00, 0x60, 0x94, 0xeb, 0x55, 0x2f, 0x00, 0xc0, /* .`..U/.. */
0x4f, 0x6b, 0x9f, 0xe0, 0x08, 0x00, 0x45, 0x00, /* Ok....E. */
0x00, 0x3f, 0x3c, 0x89, 0x00, 0x00, 0x40, 0x11, /* .?<...@. */
0x85, 0x78, 0x0a, 0x00, 0x00, 0x01, 0x92, 0x54, /* .x.....T */
0x1c, 0x58, 0x04, 0x00, 0x00, 0x35, 0x00, 0x08, /* .X...5.. */
0x25, 0xea, 0x4a, 0x30, 0x00, 0x00, 0x00, 0x01, /* %.J0.... */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x0e, /* ........ */
0xc0, 0x0c, 0xc0, 0x10, 0xc0, 0x17, 0xc0, 0x20, /* .......  */
0xc0, 0x27, 0xc0, 0x30, 0xc0, 0xff, 0xcf, 0x00, /* .'.0.... */
0x00, 0x00, 0x01, 0x00, 0x01                    /* ..... */
};
	sendpkt(pkt2 + 42, 77 - 42);

/* Frame (147 bytes) - exploit, creating a very long domain through multiple decompression of the same hostname, again and again. */
static unsigned char pkt3[147] = {
0x00, 0x60, 0x94, 0xeb, 0x55, 0x2f, 0x00, 0xc0, /* .`..U/.. */
0x4f, 0x6b, 0x9f, 0xe0, 0x08, 0x00, 0x45, 0x00, /* Ok....E. */
0x00, 0x85, 0x3d, 0x89, 0x00, 0x00, 0x40, 0x11, /* ..=...@. */
0x84, 0x32, 0x0a, 0x00, 0x00, 0x01, 0x92, 0x54, /* .2.....T */
0x1c, 0x58, 0x04, 0x00, 0x00, 0x35, 0x00, 0x08, /* .X...5.. */
0x28, 0x67, 0xff, 0xcb, 0x00, 0x00, 0x00, 0x01, /* (g...... */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x74, /* ......>t */
0x68, 0x69, 0x73, 0x6c, 0x65, 0x65, 0x74, 0x6f, /* hisleeto */
0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x77, 0x69, /* stringwi */
0x6c, 0x6c, 0x63, 0x72, 0x61, 0x73, 0x68, 0x79, /* llcrashy */
0x6f, 0x75, 0x72, 0x6c, 0x69, 0x74, 0x74, 0x6c, /* ourlittl */
0x65, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x65, 0x72, /* enameser */
0x76, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x73, 0x75, /* verforsu */
0x72, 0x65, 0x68, 0x61, 0x68, 0x61, 0x68, 0x61, /* rehahaha */
0x68, 0x61, 0x68, 0x61, 0x68, 0xc0, 0x0c, 0xc0, /* hahah... */
0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, /* ........ */
0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, /* ........ */
0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, 0x0c, 0xc0, /* ........ */
0x0c, 0xc0, 0x0c                                /* ... */
};
	sendpkt(pkt3 + 42, 147 - 42);
}

// checking flags
static void test_flags(void) {
	printf("TESTING: DNS flags\n");
	pktcnt = 0;

	// standard answer
/* Frame (132 bytes) */
static unsigned char pkt1[132] = {
0x00, 0x05, 0x5d, 0xa3, 0x59, 0x00, 0x00, 0x05, /* ..].Y... */
0x5d, 0xa3, 0x57, 0xeb, 0x08, 0x00, 0x45, 0x00, /* ].W...E. */
0x00, 0x76, 0x03, 0x2e, 0x40, 0x00, 0x40, 0x11, /* .v..@.@. */
0xfb, 0x1c, 0x0a, 0x14, 0x14, 0x01, 0x0a, 0x14, /* ........ */
0x14, 0x04, 0x00, 0x35, 0x80, 0x00, 0x00, 0x62, /* ...5...b */
0x26, 0x27, 0x31, 0xa9, 0x85, 0x83, 0x00, 0x01, /* &'1..... */
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x06, 0x72, /* .......r */
0x6f, 0x75, 0x74, 0x65, 0x72, 0x0c, 0x66, 0x61, /* outer.fa */
0x72, 0x2d, 0x66, 0x61, 0x72, 0x2d, 0x61, 0x77, /* r-far-aw */
0x61, 0x79, 0x00, 0x00, 0x01, 0x00, 0x01, 0xc0, /* ay...... */
0x13, 0x00, 0x06, 0x00, 0x01, 0x00, 0x01, 0x51, /* .......Q */
0x80, 0x00, 0x29, 0x04, 0x65, 0x73, 0x65, 0x6c, /* ..).esel */
0x05, 0x73, 0x75, 0x6d, 0x70, 0x66, 0xc0, 0x13, /* .sumpf.. */
0x05, 0x61, 0x64, 0x6d, 0x69, 0x6e, 0xc0, 0x31, /* .admin.1 */
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x2a, 0x30, /* ......*0 */
0x00, 0x00, 0x0e, 0x10, 0x00, 0x09, 0x3a, 0x80, /* ......:. */
0x00, 0x01, 0x51, 0x80                          /* ..Q. */
};
	sendpkt(pkt1 + 42, 132 - 42);

	// zone transfer
/* Frame (239 bytes) */
static unsigned char pkt2[239] = {
0x00, 0x05, 0x5d, 0xa3, 0x57, 0xeb, 0x00, 0x05, /* ..].W... */
0x5d, 0xa3, 0x59, 0x00, 0x08, 0x00, 0x45, 0x00, /* ].Y...E. */
0x00, 0xe1, 0x03, 0x76, 0x40, 0x00, 0x40, 0x11, /* ...v@.@. */
0xfa, 0x69, 0x0a, 0x14, 0x14, 0x04, 0x0a, 0x14, /* .i...... */
0x14, 0x01, 0x80, 0x00, 0x00, 0x35, 0x00, 0xcd, /* .....5.. */
0x22, 0xcc, 0x21, 0xeb, 0x28, 0x00, 0x00, 0x01, /* ".!.(... */
0x00, 0x01, 0x00, 0x02, 0x00, 0x01, 0x0c, 0x66, /* .......f */
0x61, 0x72, 0x2d, 0x66, 0x61, 0x72, 0x2d, 0x61, /* ar-far-a */
0x77, 0x61, 0x79, 0x00, 0x00, 0x06, 0x00, 0x01, /* way..... */
0x09, 0x61, 0x63, 0x61, 0x64, 0x65, 0x6d, 0x79, /* .academy */
0x30, 0x34, 0xc0, 0x0c, 0x00, 0xff, 0x00, 0xfe, /* 04...... */
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1e, /* ........ */
0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x96, /* ........ */
0x00, 0x04, 0x0a, 0x14, 0x14, 0x14, 0xc0, 0x1e, /* ........ */
0x00, 0x10, 0x00, 0x01, 0x00, 0x00, 0x00, 0x96, /* ........ */
0x00, 0x23, 0x22, 0x33, 0x31, 0x35, 0x64, 0x34, /* .#"315d4 */
0x38, 0x31, 0x61, 0x66, 0x62, 0x64, 0x32, 0x65, /* 81afbd2e */
0x62, 0x35, 0x35, 0x62, 0x33, 0x61, 0x64, 0x61, /* b55b3ada */
0x38, 0x38, 0x35, 0x31, 0x63, 0x64, 0x64, 0x31, /* 8851cdd1 */
0x65, 0x32, 0x64, 0x34, 0x34, 0x0c, 0x44, 0x48, /* e2d44.DH */
0x43, 0x50, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, /* CP_UPDAT */
0x45, 0x52, 0x00, 0x00, 0xfa, 0x00, 0xff, 0x00, /* ER...... */
0x00, 0x00, 0x00, 0x00, 0x3a, 0x08, 0x48, 0x4d, /* ....:.HM */
0x41, 0x43, 0x2d, 0x4d, 0x44, 0x35, 0x07, 0x53, /* AC-MD5.S */
0x49, 0x47, 0x2d, 0x41, 0x4c, 0x47, 0x03, 0x52, /* IG-ALG.R */
0x45, 0x47, 0x03, 0x49, 0x4e, 0x54, 0x00, 0x00, /* EG.INT.. */
0x00, 0x41, 0x5c, 0x2a, 0x76, 0x01, 0x2c, 0x00, /* .A\*v.,. */
0x10, 0x51, 0x3c, 0xa7, 0xea, 0x99, 0x30, 0xbe, /* .Q<...0. */
0xc3, 0x0e, 0x8c, 0x56, 0x55, 0x87, 0xc0, 0x29, /* ...VU..) */
0x9b, 0x21, 0xeb, 0x00, 0x00, 0x00, 0x00        /* .!..... */
};
	sendpkt(pkt2 + 42, 239 - 42);




}

static void usage(void) {
	printf("Usage: ptest test#number\n");
	printf("Example: ptest test3\n");
}

int main(int argc, char **argv) {
	if (argc != 2) {
		fprintf(stderr, "Error: invalid number of arguments\n");
		usage();
		exit(1);
	}

	if (strcmp(argv[1], "debug") == 0) {
		test_debug();
		return 0;
	}


	if (strcmp(argv[1], "test1") == 0)
		test_pktlen();
	else if (strcmp(argv[1], "test2") == 0)
		test_wrongclass();
	else if (strcmp(argv[1], "test3") == 0)
		test_rrtype();
	else if (strcmp(argv[1], "test4") == 0)
		test_wrongqsection();
	else if (strcmp(argv[1], "test5") == 0)
		test_compressedq();
	else if (strcmp(argv[1], "test6") == 0)
		test_classicexploits();
	else if (strcmp(argv[1], "test7") == 0)
		test_flags();

	fprintf(stderr, "Testing done\n");
	return 0;
}
